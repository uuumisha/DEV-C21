//Стандартная библиотека шаблонов - STL 
	//Контейнеры стандартной библиотеки - vector
	//Итераторы

#include <iostream>
#include <vector>
#include <list>
#include "inc/my_vector_funcs.h"
#include "inc/myString.h"
#include "inc/Point.h"


#pragma warning(disable: 4786)


using namespace std;	

#define	  stop __asm nop


int main()
{
	// Контейнер стандартной библиотеки vector 

//////////////////////////////////////////////////////////////////////
	//Создание векторов. 

	//Создайте следующие вектора:
	//---------------------------
	//пустой вектор целых чисел - vInt и проверьте с помощью функции size(),
	//что его размер нулевой. 
	vector<int> vInt;
	cout << "sizeof(vInt) = " << vInt.size() << endl;
	
	
	//Раскомментируйте следующий фрагмент, подумайте - все ли корректно
	//Если есть некорректности, - исправьте

	vInt.push_back(0);
	vInt.front() = 1;


	//С помощью функции push_back() в цикле заполните вектор какими-либо значениями.
	//На каждой итерации цикла следите за размером вектора с помощью методов
	//size(), capacity(), max_size() и выводите значения элементов. 
	//
	//Подсказка: так как такая проверка понадобится Вам и в следующих заданиях,
	//напишите шаблон функции, которая для вектора, содержащего элементы любого типа
	//выводит его "реквизиты" и значения элементов на консоль.

	for (int i = 0; i < 5; i++) vInt.push_back(i);
	print_vector_info(vInt);
	
	stop

	//вектор вещественных - vDouble1 с заданным Вами начальным размером  и
	//проверьте результат с помощью созданного Вами шаблона. Как будут
	//проинициализированы элементы вектора? (нулями)

	vector<double> vDouble1(10);
	vDouble1.at(0) = 1.1;
	print_vector_info(vDouble1);

	stop

	//вектор объектов типа MyString с начальным размером - 5 элементов
	//и инициализацией каждого элемента строкой "A"
	//C помощью функции at() а также с помощью оператора
	//индексирования []  измените значения каких-либо элементов.
	//Попробуйте "выйти" за границы вектора с помощью at() и
	//с помощью []. 

	vector<MyString> vectorMyString(5, "A");
	vectorMyString[0] = "B";
	vectorMyString.at(1) = "C";
	cout << "vectorMyString:\n";
	print_vector_info(vectorMyString);
		
	//vectorMyString[5] = "D";
	//vectorMyString[5] = "E";

	stop




	//вектор вещественных - vDouble3, который является копией элементов
	// [0,5) массива вещественных чисел dMas. Предворительно массив dMas 
	//нужно создать и проинициализировать!

	const size_t dMas_size = 6;
	double dMas[dMas_size] = { 0.0,1.1,2.2,3.3,4.4,5.5 };
	vector<double> vDouble3(&dMas[0], &dMas[5]);
	cout << "vDouble3:\n";
	print_vector_info(vDouble3);
	stop


	//вектор вещественных - vDouble4, который является копией элементов
	// [2,5) вектора vDouble3.
	vector<double> vDouble4(vDouble3.begin() + 2, vDouble3.begin() + 5);
	cout << "vDouble4:\n";
	print_vector_info(vDouble4);
	stop


	//вектор элементов типа Point - vPoint1 а) с начальным размером 3. Какой конструктор
	//будет вызван для каждого элемента?
	//b) vPoint2 с начальным размером 5 и проинициализируйте каждый элемент координатами (1,1).
	vector<Point> vPoint1(3);
	vector<Point> vPoint2(5, Point(1, 1));

	stop

	//вектор указателей на Point - vpPoint с начальным размером 5
	//Подумайте: как корректно заставить эти указатели "указывать" на объекты Point
	{
		vector<Point*> vpPoint(5);
		for (int i = 0; i < 5; i++)	
			vpPoint[i] = new Point(i, i);

	//Подсказка: для вывода на печать значений скорее всего Вам понадобится
		//а) специализация Вашей шаблонной функции
		//б) или перегрузка operator<< для Point*
		print_vector_info(vpPoint);

		for (int i = 0; i < 5; i++)
			delete vpPoint[i];

	}//Какие дополнительные действия нужно предпринять для такого вектора?


	///////////////////////////////////////////////////////////////////////
	//Резервирование памяти.
	//Подумайте, всегда ли верны приведенные ниже проверки?
		
		{
		size_t n = 10;
		vector<int> v(n);
		v.resize(n/2);
		if (v.capacity() == n) cout << "v.capacity()   equal " << n << endl;  //true? (да)
		else                   cout << "v.capacity() inequal " << n << endl;
		//print_vector_info(v);
		}
		
		{
		int n = 4;
		size_t m = 8;
		vector<int> v(n);
		v.reserve(m);
		if(v.capacity() == m) cout << "v.capacity()   equal " << m << endl;  //true? (да)
		else                   cout << "v.capacity() inequal " << m << endl;
		//print_vector_info(v);
		}
		
		{
		vector<int> v(3,5);
		v.resize(4,10); //значения? (добавляется 1 элемент со значением 10)
		v.resize(5); //значения?	(добавляется 1 элемент со значением 0)
	
		}

	//Создайте два "пустых" вектора с элементами
	//любого (но одного и того же типа) типа. 
	//В первом векторе зарезервируйте память под 5 элементов, а потом заполните
	//его значениями с помощью push_back.
	//Второй вектор просто заполните значениями посредством push_back.
	//
	//Сравните размер, емкость векторов и значения элементов

	vector<int> vtest1, vtest2;
	vtest1.reserve(5);
	for (int i = 0; i < 5; i++) vtest1.push_back(i);
	for (int i = 0; i < 5; i++) vtest2.push_back(i);

	print_vector_info(vtest1);
	print_vector_info(vtest2);



	



	//!!! shrink_to_fit - Уменьшение емкости вектора.
	//Для любого вектора из предыдущего задания требуется уменьшить емкость
	//до size.
	vtest2.shrink_to_fit();
	print_vector_info(vtest2);
	

	//Создание "двухмерного вектора" - вектора векторов
	//Задан одномерный массив int ar[] = {11,2,4,3,5};
	//Создайте вектор векторов следующим образом:
	//вектор vv[0] - содержит 11 элементов со значением 11
	//vv[1] - содержит 2,2
	//vv[2] - содержит 4,4,4,4
	//...
	//Распечатайте содержимое такого двухмерного вектора по строкам

	int ar[] = { 11,2,4,3,5 };
	vector<vector<int>> matrix(sizeof(ar) / sizeof(int));
	for (int i = 0; i < sizeof(ar) / sizeof(int); i++) {
		matrix[i].reserve(ar[i]);
		for (int j = 0; j < ar[i]; j++) {
			matrix[i].push_back(ar[i]);
		}
	}
	cout << "I'm a matrix (2-x vector):\n";
	cout << matrix.size() << " " << matrix[1].size() << "\n";
	//for (size_t i = 0; i < matrix.size(); i++) {
	//	for (size_t j = 0; j < matrix[i].size(); j++) {
	//		printf("%02d ", matrix[i][j]);
	//	}
	//	cout << endl;
	//}
	//cout << matrix; Миша перегрузи
	
	stop

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Вставка элемента последовательности insert(). (сделать не через стандартную функцию)
	//В вектор vChar2 вставьте в начало вектора символ только при
	//условии, что в векторе такого еще нет.
	
	vector<char> vChar2 = {'A','B', 'C'};
	char ch1 = 'B', ch2 = 'D';

	//find(vChar2.begin(), vChar2.end(), ch1);

	if (!isExist(vChar2, ch1))
		vChar2.insert(vChar2.begin(), ch1);

	if (!isExist(vChar2, ch2))
		vChar2.insert(vChar2.begin(), ch2);
	
	//Вставьте перед каждым элементом вектора vChar2 букву 'W'
	size_t cnt = 0;
	size_t vChar2Size = vChar2.size();
	for (size_t i = 0; i < vChar2Size; i++) {
		vChar2.insert(vChar2.begin() + cnt, 'W');
		cnt += 2;
	}


///////////////////////////////////////////////////////////////////
	//Напишите функцию, которая должна удалять только повторяющиеся последовательности.
	//Например: было - "qwerrrrty12222r3", стало - "qwety1r3"

	{
		vector<char> vChar3 = { 'q', 'w', 'e', 'r', 'r', 'r', 'r', 't', 'y', '1', '2', '2', '2', '2', 'r', '3' };
		deleteRetryElements(vChar3);
	}


	stop

	///////////////////////////////////////////////////////////////////

	//Удаление элемента последовательности erase()
	//Напишите функцию удаления из любого вектора всех дублей 
	
	vector<char> vChar3 = { 'q', 'w', 'e', 'r', 'r', 'r', 'r', 't', 'y', '1', '2', '2', '2', '2', 'r', '3' };
	deleteEveryDubli(vChar3);

	

///////////////////////////////////////////////////////////////////
	//Создайте новый вектор таким образом, чтобы его элементы стали
	//копиями элементов любого из созданных ранее векторов, но расположены
	//были бы в обратном порядке

	//reverse(vChar3.begin(), vChar3.end());
	vector<char> vChar4(vChar3.rbegin(), vChar3.rend());
	


///////////////////////////////////////////////////////////////////

	//Задание 1. Списки. Операции, характерные для списков.
	//Создайте пустой список из элементов Point - ptList1 и наполните
	//его значениями с помощью методов push_back(),
	//push_front, insert()
	list<Point> ptList1;
	ptList1.push_back(Point(0, 0));
	ptList1.push_front(Point(1, 1));
	ptList1.insert(ptList1.begin(), Point(2, 2));
	list<Point>::iterator it = ptList1.begin();
	advance(it, 1);
	//cout << *(advance(ptList1.begin(),3));
	cout << *it;
	

	//Напишите шаблон функции, которая будет выводить элементы
	//ЛЮБОГО КОНТЕЙНЕРА на печать. Проверьте работу шаблона на контейнерах
	//vector и list. Подсказка - хотелось бы увидеть тип контейнера.
	//cout << typeid(ptList1);
	//ptList1.get_allocator
	print_container_info(ptList1);

	//Сделайте любой из списков "реверсивным" - reverse()
	ptList1.reverse();

	//Создайте список ptList2 из элементов Point таким образом, чтобы он стал 
	//копией вектора элементов типа Point, но значения элементов списка располагались
	//бы в обратном порядке 
	list<Point> ptList2(ptList1);
	ptList2.reverse();

	//Отсортируйте списки  ptList1 и ptList2 - методом класса list - sort()
	//по возрастанию.
	//Подумайте: что должно быть перегружено в классе Point для того, чтобы
	//работала сортировка (операторы > <)
	ptList1.sort();
	ptList2.sort();


	


	stop

	//Объедините отсортированные списки - merge(). Посмотрите: что
	//при этом происходит с каждым списком.
	ptList1.merge(ptList2);
	
	stop

	//Исключение элемента из списка - remove()
	//Исключите из списка элемент с определенным значением.
	//Подумайте: что должно быть перегружено в классе Point?

	ptList1.remove(Point(1,1));

	//Исключение элемента из списка, удовлетворяющего заданному условию:
	//любая из координат отрицательна - remove_if(). 
	
	ptList1.push_front(Point(-1,-1));
	//ptList1.remove_if();

	//Исключение из списка подряд расположенных дублей - unique(). 
	ptList1.unique();
	stop

///////////////////////////////////////////////////////////////////
	//Задание 2.Очередь с двумя концами - контейнер deque

	//Создайте пустой deque с элементами типа Point. С помощью
	//assign заполните deque копиями элементов вектора. С помощью
	//разработанного Вами в предыдущем задании универсального шаблона
	//выведите значения элементов на печать



	//Создайте deque с элементами типа MyString. Заполните его значениями
	//с помощью push_back(), push_front(), insert()
	//С помощью erase удалите из deque все элементы, в которых строчки
	//начинаются с 'A' или 'a'




	return 0;
}